# Level 3: Finite Differences and the Heat Equation

::: {.dialogue}
**Pavni:** Acharya, how do we actually *approximate* derivatives for a computer?

**Acharya:** We use the **finite difference method**. Since a computer can only work with discrete points, we replace continuous derivatives with difference quotients on a **grid**.

**Pavni:** A grid? Like equally spaced points?

**Acharya:** Exactly. Suppose we have points $x_0, x_1, \dots, x_N$ with spacing $\Delta x$. Then:
- **Forward difference** for the first derivative:
  $$
  u'(x_i) \approx \frac{u(x_{i+1}) - u(x_i)}{\Delta x}
  $$
- **Backward difference**:
  $$
  u'(x_i) \approx \frac{u(x_i) - u(x_{i-1})}{\Delta x}
  $$
- **Central difference**:
  $$
  u'(x_i) \approx \frac{u(x_{i+1}) - u(x_{i-1})}{2\Delta x}
  $$

**Pavni:** Which one is better?

**Acharya:** Central differences are usually more accurate (error $\mathcal{O}((\Delta x)^2)$). Forward and backward are first-order accurate (error $\mathcal{O}(\Delta x)$).  
For the **second derivative**, we use:
$$
u''(x_i) \approx \frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{(\Delta x)^2}.
$$

**Pavni:** So we can replace calculus by algebra using these formulas?

**Acharya:** Precisely. Now let us apply this to a PDE.
:::

---

## Application: The Heat Equation

::: {.dialogue}
**Acharya:** Consider the 1D heat equation:
$$
u_t = \alpha u_{xx}, \quad 0 < x < 1,\; t>0
$$
with boundary conditions $u(0,t) = u(1,t) = 0$ and initial profile $u(x,0) = f(x)$.

We set up a grid:
- In space: $x_i = i\Delta x,\; i=0,\dots,N$  
- In time: $t^n = n\Delta t,\; n=0,1,2,\dots$

At each point, let $u_i^n \approx u(x_i,t^n)$.

**Pavni:** And now we replace derivatives?

**Acharya:** Correct.  
- Time derivative (forward difference):
  $$
  u_t(x_i,t^n) \approx \frac{u_i^{n+1} - u_i^n}{\Delta t}
  $$
- Spatial second derivative (central difference):
  $$
  u_{xx}(x_i,t^n) \approx \frac{u_{i-1}^n - 2u_i^n + u_{i+1}^n}{(\Delta x)^2}
  $$

Plugging these into the PDE, we get:
$$
\frac{u_i^{n+1} - u_i^n}{\Delta t} = \alpha \,\frac{u_{i-1}^n - 2u_i^n + u_{i+1}^n}{(\Delta x)^2}.
$$

Rearranging:
$$
u_i^{n+1} = u_i^n + \lambda\,(u_{i-1}^n - 2u_i^n + u_{i+1}^n),
$$
where $\lambda = \frac{\alpha \Delta t}{(\Delta x)^2}$.
:::

---

## Stability Condition

::: {.dialogue}
**Pavni:** So we can just keep applying this formula to march forward in time?

**Acharya:** Yes, but with a caveat. This scheme, called **FTCS (Forward Time, Central Space)**, is only stable if:
$$
\lambda \leq \tfrac{1}{2}.
$$

**Pavni:** So if $\Delta t$ is too large, the scheme fails?

**Acharya:** Exactly. The numerical solution will blow up, even though the true solution is stable. Choosing $\Delta t$ small enough ensures stability.
:::

---

## Mini-Quizzes
::: {.quiz}
**Quiz 1:**  
Let $u(x) = x^2$. With $\Delta x = 0.1$, approximate $u'(1)$ using:  
1. Forward difference  
2. Central difference  

Compare with the exact derivative $u'(1) = 2$. Which is more accurate?
:::

::: {.callout-tip collapse=true}
### Answer 1

- Forward difference:
  $$
  \frac{u(1+\Delta x)-u(1)}{\Delta x}=\frac{(1.1)^2-1^2}{0.1}=\frac{1.21-1}{0.1}=2.1.
  $$

- Central difference:
  $$
  \frac{u(1+\Delta x)-u(1-\Delta x)}{2\Delta x}
  =\frac{(1.1)^2-(0.9)^2}{0.2}=\frac{1.21-0.81}{0.2}=2.0.
  $$

- Exact derivative: $u'(1)=2$.

**Conclusion:** The central difference gives the exact value here (error $0$), while the forward difference has error $0.1$. Central is more accurate (as expected — it is second-order).
:::

---

::: {.quiz}
**Quiz 2:**  
Suppose $\alpha = 1$, $\Delta x = 0.1$. What is the maximum $\Delta t$ for stability in the explicit scheme?  

(Hint: $\lambda = \dfrac{\alpha \Delta t}{(\Delta x)^2} \leq \tfrac{1}{2}$.)
:::

::: {.callout-tip collapse=true}
### Answer 2

We need
$$
\lambda=\frac{\alpha\,\Delta t}{(\Delta x)^2}\le\frac{1}{2}.
$$
With $\alpha=1$ and $\Delta x=0.1$, $(\Delta x)^2=0.01$. So
$$
\frac{\Delta t}{0.01}\le\frac{1}{2}\quad\Rightarrow\quad
\Delta t \le 0.01\times\frac{1}{2}=0.005.
$$

**Maximum allowable** $\displaystyle \Delta t = 0.005$.
:::


## Heat equation — FTCS (matrix form)

This example shows the FTCS matrix method for the 1D heat equation and produces snapshot plots.

```{python echo=false}
import numpy as np
import matplotlib.pyplot as plt

alpha = 1.0
Nx    = 50
T     = 0.1
L, R  = 0.0, 0.0

dx = 1.0/(Nx-1)
dt_max = dx*dx/(2*alpha)
s  = 0.4
dt = s*dt_max
Nt = int(T/dt)
dt = T/Nt
r  = alpha*dt/dx**2

x  = np.linspace(0.0, 1.0, Nx)
u0 = np.sin(np.pi * x)

m = Nx - 2
main = (1 - 2*r) * np.ones(m)
off  = r * np.ones(m-1)
A = np.diag(main) + np.diag(off,1) + np.diag(off,-1)

b = np.zeros(m)
b[0], b[-1] = r*L, r*R

u = u0.copy()
u_in = u[1:-1].copy()
snapshots = []
snap_times = np.linspace(0, Nt-1, 5, dtype=int)

for j in range(Nt):
    u_in = A @ u_in + b
    u[1:-1] = u_in
    if j in snap_times or j == Nt-1:
        snapshots.append((j*dt, u.copy()))

plt.figure(figsize=(8,4))
first_exact = True
for t_here, u_snap in snapshots:
    # numerical
    plt.plot(x, u_snap, label=f"num t={t_here:.3f}")
    # exact
    u_exact = np.exp(-np.pi**2*alpha*t_here) * np.sin(np.pi*x)
    if first_exact:
        plt.plot(x, u_exact, 'k--', linewidth=1.2, label='exact solution')
        first_exact = False
    else:
        plt.plot(x, u_exact, 'k--', linewidth=1.2, label="_nolegend_")

plt.xlabel('x'); plt.ylabel('u(x,t)')
plt.title('Heat equation: numerical vs exact')
plt.legend(fontsize='small')
plt.grid(True)
plt.show()
```