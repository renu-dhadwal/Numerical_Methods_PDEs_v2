---
title: "Level 5 — Hyperbolic PDEs"
format:
  html:
    math: mathjax
---

**Pavni:** Acharya, we’ve studied the heat equation. From theory we know that it seems to *spread* information everywhere. Does every PDE behave like that?

**Acharya:** That’s a good observation, Pavni. Not every PDE diffuses information infinitely fast like the parabolic heat equation.  
Some equations describe situations where information or disturbances travel at a *finite speed* — like waves or moving traffic.

**Pavni:** So these are called *hyperbolic equations*?

**Acharya:** Exactly. Hyperbolic equations are the mathematical way of describing signals or quantities that *move* through a medium rather than *diffuse*.  
For example — a vibrating string, sound waves in air, or even cars moving on a road.

**Pavni:** Interesting! But why are they so different from diffusion equations like the heat equation?

**Acharya:** Because diffusion equations allow disturbances to spread instantaneously everywhere — a small change at one point affects all others immediately.  
That’s called **infinite propagation speed**.  
But hyperbolic equations restrict influence to certain *paths* in the $(x,t)$-plane, called **characteristics**.  
Information travels only along these paths at a finite speed.

**Pavni:** That sounds more physical. After all, signals, sound, or cars don’t move infinitely fast!

**Acharya:** Exactly. Let’s begin with a simple and familiar example — **traffic flow**.  
It beautifully captures the idea of *conservation* and *finite-speed motion*.

---

## 🚗 The Traffic Flow Model

**Pavni:** So, where do we begin?

**Acharya:** Let’s define some quantities.

- $\rho(x,t)$: density of cars at position $x$ and time $t$ (cars/km)  
- $v(x,t)$: average speed of cars (km/h)  
- $q(x,t)$: flow rate — number of cars passing a point per unit time (cars/hour)

**Pavni:** So $q$ must depend on both how many cars there are and how fast they move?

**Acharya:** Precisely. That leads us to the simple physical relation:
$$
q = \rho v.
$$

<details>
<summary>💡 Why $q = \rho v$?</summary>

If a small segment of road of length $\Delta x$ contains $\rho \, \Delta x$ cars,  
and each car moves with velocity $v$, then in time $\Delta t$ each car covers $v \, \Delta t$ km.  
So, the number of cars passing a fixed point in time $\Delta t$ is  
$$
(\rho \, \Delta x) \cdot \frac{v \, \Delta t}{\Delta x} = \rho v \, \Delta t.
$$
Dividing by $\Delta t$ gives $q = \rho v$.
</details>

---

## ⚙️ Conservation of Cars

**Acharya:** Now, think of a small stretch of road between $x_1$ and $x_2$.  
Cars can only leave or enter through the ends.

$$
\frac{d}{dt}\int_{x_1}^{x_2} \rho(x,t)\,dx = q(x_1,t) - q(x_2,t).
$$

**Pavni:** That looks like conservation of mass!

**Acharya:** Exactly — just conservation of the *number of cars*.  
The total number of cars in the interval changes only because of the *net flow* at the boundaries.  

Now, let’s use the **Fundamental Theorem of Calculus** to convert this integral form into a *local differential equation*.

By the Fundamental Theorem of Calculus,
$$
q(x_2,t) - q(x_1,t) = \int_{x_1}^{x_2} q_x(x,t)\,dx.
$$

Substitute this into our conservation statement:
$$
\frac{d}{dt}\int_{x_1}^{x_2} \rho(x,t)\,dx = -\int_{x_1}^{x_2} q_x(x,t)\,dx.
$$
Assuming $\rho$ is smooth enough to interchange differentiation and integration:
$$
\int_{x_1}^{x_2} \rho_t(x,t)\,dx = -\int_{x_1}^{x_2} q_x(x,t)\,dx.
$$

Combine both integrals:
$$
\int_{x_1}^{x_2} \big[\rho_t(x,t) + q_x(x,t)\big]\,dx = 0.
$$

**Acharya:** Now, Pavni, what does this equation tell us?

**Pavni:** It says that the integral of $\rho_t + q_x$ over *any* interval is zero.

**Acharya:** Exactly! And that can only happen if the integrand itself is zero *everywhere*.  
Hence, we get the **local conservation law**:
$$
\boxed{\rho_t + q_x = 0.}
$$

**Pavni:** So the integral form expresses the total number of cars in a segment being conserved,  
and this differential form expresses that conservation *at every point* on the road!

**Acharya:** Perfectly said. This is the basic **conservation law** for one-dimensional flow.  
Next, if we assume each car moves at a constant speed $a$, we’ll get the **linear advection equation.**

**Pavni:** So this describes a traffic pattern moving forward without changing its shape?

**Acharya:** Exactly. The entire profile of car density just shifts rightward with speed $a$.

---

## ✏️ Try to Predict

**Acharya:** Before solving it, can you guess how the density will evolve if initially the density is a bump — say,
$$
\rho(x,0) = e^{-x^2}?
$$

**Pavni:** I think it will move to the right, keeping its shape.

**Acharya:** Perfect intuition. We’ll now confirm this mathematically using **characteristics** — special curves along which information travels.

---

## 🌊 Characteristics and the Solution of the Linear Advection Equation

**Pavni:** Acharya, now that we have derived the equation  
$$
\rho_t + a\rho_x = 0, \quad a > 0,
$$  
for cars moving at constant speed, how do we actually find $\rho(x,t)$ from this?

**Acharya:** Excellent question. This equation may look simple, but it contains a beautiful idea — that **information travels along certain paths** in the $(x,t)$-plane. These paths are called *characteristics*.

---

### Deriving the Characteristic Curves

**Acharya:** Let’s think of $\rho$ as a function of both $x$ and $t$.  
Suppose we move along a curve $x = x(t)$ in the $(x,t)$-plane.  
By the chain rule, the total derivative of $\rho$ along that curve is
$$
\frac{d\rho}{dt} = \rho_t + \frac{dx}{dt}\rho_x.
$$

Now, if we choose $\dfrac{dx}{dt} = a$, then
$$
\frac{d\rho}{dt} = \rho_t + a\rho_x = 0.
$$

That means $\rho$ is **constant** along any curve that satisfies $\dfrac{dx}{dt} = a$.

**Pavni:** So those are the characteristic curves?

**Acharya:** Exactly! Integrating $\dfrac{dx}{dt} = a$ gives
$$
x = a t + x_0, \quad \text{or} \quad x - a t = x_0 = \text{constant}.
$$

Each line $x - a t = \text{constant}$ is a **characteristic line**.

---

### The Meaning of Characteristics

**Pavni:** What does it mean that $\rho$ is constant along these lines?

**Acharya:** It means that the value of $\rho$ at time $t$ and position $x$  
is exactly the same as its value at the point where that characteristic line started on the $x$-axis (that is, at time $t=0$).

So,
$$
\rho(x,t) = \rho_0(x - a t),
$$
where $\rho_0(x)$ is the initial density at $t=0$.

**Pavni:** Oh! So the initial profile just shifts by $a t$?

**Acharya:** Exactly — it moves to the right if $a>0$ and to the left if $a<0$.  
No change in shape — pure translation.

---

### Verifying the Solution

**Pavni:** Let’s check if this really satisfies the PDE.

**Acharya:** Sure! Let $\rho(x,t) = \rho_0(x - a t)$.  
Then
$$
\rho_t = -a\rho_0'(x - a t), \quad \rho_x = \rho_0'(x - a t).
$$
Substitute into $\rho_t + a\rho_x = 0$:
$$
(-a\rho_0') + a\rho_0' = 0.
$$
✅ It satisfies the equation perfectly.

---

### Understanding Finite Propagation Speed

**Acharya:** The key property of this equation is that information moves at a *finite speed*.

If a disturbance is initially present only between $x=0$ and $x=1$,  
then at time $t$ it will be found only between $x=a t$ and $x=1+a t$.  
Every point outside this region remains unaffected.

**Pavni:** So information doesn’t spread instantly like in the heat equation?

**Acharya:** Exactly. In the **heat equation**, even a small bump affects the whole line immediately — infinite propagation speed.  
But here, the influence travels only along straight lines $x - a t = \text{constant}$ — that’s **finite-speed propagation**.

---

### Example

Let’s take an initial density
$$
\rho_0(x) =
\begin{cases}
1, & 0 < x < 1, \\
0, & \text{otherwise}.
\end{cases}
$$

Then
$$
\rho(x,t) =
\begin{cases}
1, & a t < x < 1 + a t, \\
0, & \text{otherwise}.
\end{cases}
$$

**Pavni:** So the block of cars just moves forward as a group?

**Acharya:** Exactly — like a moving traffic wave with constant shape.

---

### Visualizing Characteristics

Each characteristic line shows where information travels:

```plaintext
t ↑
  |
  |       /    /    /    /    /    /    /
  |      /    /    /    /    /    /    /
  |     /    /    /    /    /    /    /
  |____/____/____/____/____/____/____/→ x

```

## 🕸️ Domain of Dependence and Domain of Influence

**Pavni:** Acharya, you mentioned earlier that information in hyperbolic equations travels along characteristics. But how exactly do we describe *which* parts of the initial data influence the solution at a given point?

**Acharya:** Excellent question, Pavni. To answer that, we introduce two key ideas — the **domain of dependence** and the **domain of influence**. These describe how information moves through space and time.

---

###  What do these mean?

**Acharya:** Let’s begin intuitively.

- The **domain of dependence (DoD)** of a point $(x,t)$ is the set of points in the initial data that can *affect* the solution at $(x,t)$.  
  In other words: *Which initial points influence the value here?*

- The **domain of influence (DoI)** of a point $(x_0,0)$ is the set of space–time points $(x,t)$ that can be affected by that initial point.  
  In other words: *Where does the information starting at $x_0$ go?*

**Pavni:** So the DoD looks backward in time, and the DoI looks forward?

**Acharya:** Exactly. They’re like mirror images of each other.  
For hyperbolic PDEs, these regions are bounded by **characteristics** — the paths along which information travels at finite speed.

---

###  Example 1: Linear Advection

**Pavni:** Let’s try this with the advection equation again:  
$$
u_t + a\,u_x = 0, \quad u(x,0) = u_0(x).
$$

**Acharya:** Good. The characteristics are the straight lines
$$
x - a t = \text{constant}.
$$

So each point $(x,t)$ connects to exactly one point on the $x$–axis: $x_0 = x - a t$.

**Pavni:** So the value $u(x,t)$ depends only on $u_0(x - a t)$?

**Acharya:** Exactly. That means:

- The **domain of dependence** of $(x,t)$ is the **single point** $x_0 = x - a t$.  
- The **domain of influence** of an initial point $(x_0,0)$ is the **straight line** $x = x_0 + a t$.

**Pavni:** So for advection, both DoD and DoI are just lines — not regions?

**Acharya:** Right. A *single characteristic line* carries all the information.  
This is why the advection equation has such a clean propagation behavior — each point of initial data simply moves at speed $a$ without interacting with others.

---

###  Example 2: The 1-D Wave Equation

**Pavni:** What happens for the wave equation?  
$$
u_{tt} = c^2 u_{xx}.
$$

**Acharya:** Ah, this one is a bit richer. The general solution is given by d’Alembert’s formula:
$$
u(x,t) = F(x - c t) + G(x + c t).
$$

**Pavni:** So now we have two families of characteristics — one moving right, one left?

**Acharya:** Precisely! For this equation:
- Right-moving characteristics: $x - c t = \text{constant}$  
- Left-moving characteristics: $x + c t = \text{constant}$

Now, to find the value at $(x,t)$, you need both $F$ and $G$ — meaning information from **two points** on the initial line:
$$
x - c t \quad \text{and} \quad x + c t.
$$

**Pavni:** So the DoD of $(x,t)$ is the interval between those two points?

**Acharya:** Yes. The **domain of dependence** is  
$$
[x - c t,\, x + c t].
$$

And the **domain of influence** of an initial point $(x_0,0)$ is the cone-shaped region.

```{python}
#| echo: false
import numpy as np
import matplotlib.pyplot as plt


x0 = 0.0      # initial point for Domain of Influence
x = 1.0       # target point for Domain of Dependence
t = 1.0       # time at which we evaluate DoD for (x,t)
c = 1.0       # wave speed


x_min, x_max = -2.0, 3.0
t_min, t_max = -1.5, 2.0

fig, ax = plt.subplots(figsize=(7,7))


ax.axhline(0, color='k', linewidth=0.8)
ax.axvline(0, color='k', linewidth=0.8)
ax.set_xlim(x_min, x_max)
ax.set_ylim(t_min, t_max)
ax.set_xlabel(r'$x$')
ax.set_ylabel(r'$t$')
ax.set_title('Domain of Influence (upward) and Domain of Dependence (downward)')


ts_up = np.linspace(0, t_max, 200)
x_right_up = x0 + c*ts_up
x_left_up  = x0 - c*ts_up
ax.fill_betweenx(ts_up, x_left_up, x_right_up, color='C0', alpha=0.25, label='Domain of Influence of $(x_0,0)$')
ax.plot(x_right_up, ts_up, linestyle='-', color='C0')
ax.plot(x_left_up, ts_up, linestyle='-', color='C0')


ax.scatter([x0],[0], color='C0', zorder=5)
ax.text(x0, -0.15, r'$(x_0,0)$', ha='right', va='top')


ts_down = np.linspace(0, t, 200)
x_right_down = x + c*(t - ts_down)   # trace back to t=0
x_left_down  = x - c*(t - ts_down)
ax.fill_betweenx(t - ts_down, x_left_down, x_right_down, color='C1', alpha=0.25, label=f'DoD of $({x},{t})$')
ax.plot(x + c*(np.linspace(-0.0, t, 200) ), np.linspace(t,0,200), linestyle='-', color='C1')
ax.plot(x - c*(np.linspace(-0.0, t, 200) ), np.linspace(t,0,200), linestyle='-', color='C1')


ax.scatter([x],[t], color='C1', zorder=6)
ax.text(x, t+0.05, rf'$(x,t)=({x},{t})$', ha='left', va='bottom')


tline = np.linspace(t_min, t_max, 400)
ax.plot(x0 + c*tline, tline, color='gray', linestyle='--', linewidth=1)
ax.plot(x0 - c*tline, tline, color='gray', linestyle='--', linewidth=1)
ax.text(x0 + c*(t_max-0.1), t_max-0.05, r'$x = x_0 + ct$', color='gray', va='top', ha='right')
ax.text(x0 - c*(t_max-0.1), t_max-0.05, r'$x = x_0 - ct$', color='gray', va='top', ha='left')

ax.text(x + c*(t/2), t/2, r'x = x + ct ', color='C1', fontsize=8, rotation=20)
ax.text(x - c*(t/2), t/2, r'x = x - ct ', color='C1', fontsize=8, rotation=-20)


ax.set_aspect('auto')
ax.legend(loc='upper right')
ax.grid(alpha=0.2)

plt.tight_layout()
plt.savefig('doidod_plot.png', dpi=200)
plt.show()
```

## 🚦 Nonlinear Advection and the Formation of Shocks

**Pavni:** Acharya, the linear advection equation made perfect sense — the whole profile just moves without changing shape.  
But traffic jams don’t behave that nicely! Sometimes cars slow down abruptly and the jam gets worse over time.  
Does our model capture that?

**Acharya:** Excellent question, Pavni. The linear advection equation assumes that every car moves with the *same constant speed* $a$.  
But in reality, cars move **slower when the road is crowded** — so the speed depends on the density of cars, $\rho$.

**Pavni:** So $v$ depends on $\rho$? Like $v = v(\rho)$?

**Acharya:** Exactly. That makes the flux $q = \rho v(\rho)$ a nonlinear function of $\rho$.  
Substituting this into the conservation law  
$$
\rho_t + q_x = 0,
$$  
we get the **nonlinear advection equation**:
$$
\rho_t + \big(f(\rho)\big)_x = 0,
$$
where $f(\rho) = \rho v(\rho)$.

---

### Example: Traffic Flow Model

**Pavni:** What kind of $v(\rho)$ should we take?

**Acharya:** A simple and realistic choice is  
$$
v(\rho) = 1 - \rho,
$$  
meaning cars move at unit speed when the road is empty ($\rho=0$),  
and stop completely when the road is jammed ($\rho=1$).

Then  
$$
f(\rho) = \rho(1 - \rho) = \rho - \rho^2,
$$  
and our equation becomes
$$
\rho_t + (\rho - \rho^2)_x = 0.
$$

**Pavni:** Expanding that gives
$$
\rho_t + (1 - 2\rho)\rho_x = 0.
$$
So it looks just like the advection equation, but the wave speed now depends on $\rho$ itself!

**Acharya:** Exactly! This is called the **nonlinear advection equation** or **inviscid Burgers’ equation**.

---

## 🌀 Characteristics in the Nonlinear Case

**Pavni:** Earlier, for $\rho_t + a\rho_x = 0$, we had straight characteristic lines $x - at = \text{constant}$.  
How does it work here when the speed depends on $\rho$?

**Acharya:** Let’s find out. As before, along a curve $x = x(t)$, the total derivative is
$$
\frac{d\rho}{dt} = \rho_t + \frac{dx}{dt}\rho_x.
$$
From the PDE,
$$
\rho_t = -(1 - 2\rho)\rho_x.
$$
Substitute this:
$$
\frac{d\rho}{dt} = \rho_t + \frac{dx}{dt}\rho_x = \big[-(1 - 2\rho) + \frac{dx}{dt}\big]\rho_x.
$$
For $\dfrac{d\rho}{dt}=0$ along a characteristic, we must have
$$
\frac{dx}{dt} = 1 - 2\rho.
$$

**Pavni:** So, $\rho$ is constant along a curve whose slope depends on $\rho$ itself?

**Acharya:** Precisely!  
Each “traffic packet” (region of constant density) moves with its own speed $1 - 2\rho$.  
That’s the big difference from the linear case — now the **characteristics themselves depend on the solution**.

---

## 🚗 When Characteristics Meet — Shock Formation

**Pavni:** What happens if cars ahead are slower than those behind?  
Would the faster ones eventually catch up?

**Acharya:** That’s the perfect intuition. Let’s see what that means mathematically.

Suppose initially $\rho(x,0)$ decreases with $x$ — that is, higher density (slower cars) ahead, and lower density (faster cars) behind.  
Then the characteristic speed $1 - 2\rho$ is **larger behind** and **smaller ahead**.

That means characteristics **converge** — they start to intersect.  
When that happens, two different characteristic lines try to assign *different values* of $\rho$ at the same $(x,t)$.

**Pavni:** So the solution becomes *multivalued*? That’s not physical.

**Acharya:** Exactly — in reality, when cars catch up, a **shock** forms — a sharp front separating high and low densities.  
The PDE solution must then be replaced by a *weak solution* that allows for discontinuities satisfying the **Rankine–Hugoniot condition**.

---

## ⚡ The Shock Speed (Rankine–Hugoniot Condition)

Let the shock position be $x = s(t)$.  
On the left of the shock, density is $\rho_L$; on the right, it’s $\rho_R$.

Conservation of cars gives the jump condition
$$
\frac{ds}{dt} = \frac{f(\rho_L) - f(\rho_R)}{\rho_L - \rho_R}.
$$

**Pavni:** So the shock moves at a speed equal to the slope of the line joining the two points on the flux curve $f(\rho)$?

**Acharya:** Perfect!  
That’s a nice geometric interpretation — the **secant slope** between $(\rho_L, f(\rho_L))$ and $(\rho_R, f(\rho_R))$.

For our example $f(\rho) = \rho(1 - \rho)$, we get
$$
\frac{ds}{dt} = \frac{\rho_L(1 - \rho_L) - \rho_R(1 - \rho_R)}{\rho_L - \rho_R}
              = 1 - (\rho_L + \rho_R).
$$

---

## 🌊 Example: A Forming Traffic Jam

**Pavni:** Let’s take an example!

**Acharya:** Suppose the initial density is
$$
\rho(x,0) =
\begin{cases}
0.8, & x < 0, \\
0.2, & x > 0.
\end{cases}
$$

Then $\rho_L = 0.8$ (slow cars ahead) and $\rho_R = 0.2$ (fast cars behind).  
The shock speed is
$$
s' = 1 - (0.8 + 0.2) = 0.
$$

**Pavni:** So the shock doesn’t move — it stays fixed in place?

**Acharya:** Exactly! That represents a *stationary traffic jam* — cars pile up until the density behind adjusts.  
If we reverse the situation — slower cars behind faster ones — the characteristics diverge instead, creating a **rarefaction wave** rather than a shock.

---

## ✨ Key Takeaways

- Linear advection: constant-speed characteristics → waves move unchanged.  
- Nonlinear advection: speed depends on $\rho$ → characteristics can intersect.  
- When they intersect, shocks form — discontinuous but physically meaningful solutions.  
- The shock speed is determined by the Rankine–Hugoniot condition.  
- This mechanism underlies shock waves, traffic jams, and compressible fluid flows.

---

**Pavni:** Wow, so from traffic flow we’ve reached the idea of *shock waves*!  
That’s amazing — how a simple conservation law captures such complex behavior.

**Acharya:** That’s the beauty of hyperbolic equations — they describe how *information* and *discontinuities* propagate in nature.  


## 🚦 Shock Waves 

**Pavni:** Acharya, we saw how nonlinear advection can either *spread out* into a rarefaction or *pile up* into a shock. Can we work through a concrete example — step by step — and actually *see* the shock form?

**Acharya:** Absolutely. Let’s use the simple traffic-inspired Burgers'-type model we had earlier:
$$
\rho_t + (1-2\rho)\,\rho_x = 0,
$$
so the characteristic speed is
$$
c(\rho) = 1 - 2\rho.
$$

We will pick an initial condition that produces a shock:
$$
\rho(x,0)=\begin{cases}
0.2, & x<0,\\[4pt]
0.8, & x>0.
\end{cases}
$$

**Pavni:** That’s the case where the left side is sparse (fast) and the right side is dense (slow), so I expect traffic from the left to run into slow traffic on the right. That should make a shock, right?

**Acharya:** Exactly. Let’s make the statements precise.

- Left state: $\rho_L=0.2 \Rightarrow c_L = 1-2(0.2)=0.6$ (moves right).  
- Right state: $\rho_R=0.8 \Rightarrow c_R = 1-2(0.8)=-0.6$ (moves left).

The two families of characteristics coming from left and right **collide** — they cross in the $(x,t)$-plane — so the continuous solution breaks down and a shock forms.

**Pavni:** And the shock speed is given by the Rankine–Hugoniot condition?

**Acharya:** Correct. For a conservation law $\rho_t + f(\rho)_x=0$ the shock speed $s$ satisfies
$$
s = \frac{f(\rho_L)-f(\rho_R)}{\rho_L-\rho_R}.
$$
Here $f(\rho)=\rho(1-\rho)$, so for our numbers
$$
f(\rho_L)=0.2(0.8)=0.16,\qquad f(\rho_R)=0.8(0.2)=0.16,
$$
hence $s = \dfrac{0.16-0.16}{0.2-0.8}=0$.  
So this particular shock is *stationary* — the discontinuity sits at $x=0$ while characteristics run into it.

---

---
title: "Interactive Shock Formation in Burgers' Equation"
format:
  html:
    math: mathjax
---

## 🚗 Interactive Exploration — Shock vs Rarefaction

**Acharya:** Let’s play! Try changing the left and right densities using the sliders below.  
You’ll see how the characteristics behave — whether they *collide* (shock) or *spread out* (rarefaction).
```{python}
#| echo: false
#| warning: false
import numpy as np
import plotly.graph_objects as go

# --- User-editable densities (change here) ---
rho_L = 0.2
rho_R = 0.8

# flux and wave speed
f = lambda r: r * (1 - r)
a = lambda r: 1 - 2 * r  # f'(r)

# grid
x0_vals = np.linspace(-2.0, 2.0, 41)
rho0 = np.where(x0_vals < 0, rho_L, rho_R)
c_vals = a(rho0)

# time frames for animation
t_max = 2.0
n_frames = 40
t_frames = np.linspace(0, t_max, n_frames)

# Rankine–Hugoniot shock speed
if np.isclose(rho_L, rho_R):
    s = a(rho_L)
else:
    s = (f(rho_L) - f(rho_R)) / (rho_L - rho_R)

# Build frames: each frame draws characteristics up to time t_k and a shock line
frames = []
for k, tk in enumerate(t_frames):
    data = []
    # characteristics
    for i, x0 in enumerate(x0_vals):
        xs = (x0 + c_vals[i] * np.linspace(0, tk, 20)).tolist()
        ts = np.linspace(0, tk, 20).tolist()
        data.append(go.Scatter(x=xs, y=ts, mode='lines',
                               line=dict(color='royalblue', width=1),
                               showlegend=False))
    # shock line (x = s*t)
    data.append(go.Scatter(x=s * np.linspace(0, tk, 2),
                           y=np.linspace(0, tk, 2),
                           mode='lines',
                           line=dict(color='red', width=3),
                           name='Shock'))
    frames.append(go.Frame(data=data, name=str(k)))

# Base figure: start with frame 0 data
fig = go.Figure(frames=frames)
fig.add_traces(frames[0].data)

# Slider steps
steps = [dict(method="animate",
              args=[[str(i)], dict(mode="immediate",
                                   frame=dict(duration=50, redraw=True),
                                   transition=dict(duration=0))],
              label=f"{t:.2f}") for i, t in enumerate(t_frames)]
sliders = [dict(active=0, pad={"t": 30}, steps=steps, currentvalue={"prefix": "t = "})]

# Layout with time increasing upward
fig.update_layout(
    title=f"Characteristics and Shock (ρ_L={rho_L:.2f}, ρ_R={rho_R:.2f})",
    xaxis_title="x",
    yaxis_title="t (time increasing upward)",
    yaxis=dict(autorange=False, range=[0, t_max]),  # <-- fixed here
    sliders=sliders,
    updatemenus=[dict(type="buttons", showactive=False,
                      buttons=[dict(label="Play", method="animate",
                                    args=[None, {"frame": {"duration": 80, "redraw": True},
                                                 "fromcurrent": True}])])],
    width=760, height=520
)

fig.show()
```

## 🚦 A Moving Shock: When the Traffic Jam Travels

**Pavni:** Acharya, earlier we saw a stationary shock where the boundary between two traffic regions just sat still.  
Can the shock *move*?

**Acharya:** Certainly, Pavni.  
Let’s take another case:

$$
\rho(x,0) =
\begin{cases}
0.6, & x < 0,\\
0.2, & x > 0.
\end{cases}
$$

Here the left side is denser — more cars — while the right side is freer.  
Let’s see what happens.

---

### Compute the fluxes

**Acharya:** Our flux function is still $f(\rho) = \rho(1-\rho)$.  
So,

$$
f(0.6) = 0.24, \quad f(0.2) = 0.16.
$$

The shock speed is found from the **Rankine–Hugoniot condition**:

$$
s = \frac{f(\rho_L) - f(\rho_R)}{\rho_L - \rho_R}
= \frac{0.24 - 0.16}{0.6 - 0.2} = 0.2.
$$

**Pavni:** So the shock moves *to the right* with speed 0.2?

**Acharya:** Exactly.  
Because the flux on the left is higher, the congested region pushes into the free region —  
the “traffic jam” moves forward!

---

### What happens to the characteristics?

**Acharya:** Let’s look at the characteristic speeds:

$$
c_L = 1 - 2\rho_L = 1 - 1.2 = -0.2, \quad
c_R = 1 - 2\rho_R = 1 - 0.4 = 0.6.
$$

So on the left, lines tilt gently left; on the right, they tilt right.  
They intersect, and the envelope of all those intersections forms the **shock curve**:

$$
x = s t = 0.2t.
$$

---

###  Visualizing the moving shock

```{python}
#| echo: false
#| warning: false
import numpy as np
import plotly.graph_objects as go

# --- Riemann data chosen to produce an admissible moving shock ---
rho_L = 0.1   # left state (x<0)
rho_R = 0.7   # right state (x>0)

# flux and derivative
f = lambda r: r * (1 - r)
a = lambda r: 1 - 2*r    # f'(r)

# compute shock speed via Rankine-Hugoniot
fL, fR = f(rho_L), f(rho_R)
s = (fL - fR) / (rho_L - rho_R)

# grid for characteristics
x0 = np.linspace(-3.0, 3.0, 401)   # dense sampling for clear intersections
rho0 = np.where(x0 < 0, rho_L, rho_R)
a_vals = a(rho0)

t_max = 3.0
n_frames = 60
t_frames = np.linspace(0, t_max, n_frames)

# build animation frames: each frame draws characteristics up to time tk and the shock line x = s*t
frames = []
for k, tk in enumerate(t_frames):
    data = []
    for i, xinit in enumerate(x0):
        xs = xinit + a_vals[i] * np.linspace(0, tk, 20)
        ts = np.linspace(0, tk, 20)
        data.append(go.Scatter(x=xs, y=ts, mode='lines',
                               line=dict(color='royalblue', width=0.7),
                               showlegend=False))
    # shock line x = s * t from 0..tk
    data.append(go.Scatter(x=s * np.linspace(0, tk, 2), y=np.linspace(0, tk, 2),
                           mode='lines', line=dict(color='red', width=3),
                           name=f's(t) = {s:.3f} t'))
    frames.append(go.Frame(data=data, name=str(k)))

fig = go.Figure(frames=frames)
fig.add_traces(frames[0].data)

# slider steps
steps = [dict(method="animate",
              args=[[str(i)], dict(mode="immediate", frame=dict(duration=50, redraw=True), transition=dict(duration=0))],
              label=f"{t:.2f}") for i, t in enumerate(t_frames)]
sliders = [dict(active=0, pad={"t": 30}, steps=steps, currentvalue={"prefix":"t = "})]

fig.update_layout(
    title=f"Admissible moving shock: rho_L={rho_L}, rho_R={rho_R}, shock speed s={s:.3f}",
    xaxis_title="x",
    yaxis_title="t (time ↑)",
    yaxis=dict(autorange=False, range=[0, t_max]),   # time increases upward
    sliders=sliders,
    updatemenus=[dict(type="buttons", showactive=False,
                      buttons=[dict(label="Play", method="animate",
                                    args=[None, {"frame": {"duration": 60, "redraw": True}, "fromcurrent": True}])])],
    width=900, height=560
)

fig.show()
```

```{python}
#| echo: false
#| warning: false
# Interactive Riemann explorer: sliders for rho_L, rho_R; draws admissible shock or rarefaction fan.
import numpy as np
import plotly.graph_objects as go
import ipywidgets as widgets
from IPython.display import display, clear_output

# flux and derivative
f = lambda r: r * (1 - r)
a = lambda r: 1 - 2*r    # f'(r)

# plotting helper
def plot_riemann(rho_L, rho_R, t_max=3.0, n_x0=61):
    # compute speeds
    c_L = a(rho_L)
    c_R = a(rho_R)
    fL, fR = f(rho_L), f(rho_R)
    # shock speed (Rankine-Hugoniot)
    s = (fL - fR) / (rho_L - rho_R) if not np.isclose(rho_L, rho_R) else a(rho_L)

    # decide regime
    compressive = (c_L > c_R)  # if True -> shock; if False -> rarefaction

    # prepare figure
    fig = go.Figure()
    t_frames = np.linspace(0, t_max, 101)

    # characteristics from left (x0<0) and right (x0>0)
    x0_left = np.linspace(-3.0, -0.01, n_x0//2)
    x0_right = np.linspace(0.01, 3.0, n_x0//2)

    # draw characteristics as thin lines (for the whole time interval)
    for x0 in x0_left:
        xs = x0 + c_L * t_frames
        fig.add_trace(go.Scatter(x=xs, y=t_frames, mode='lines', line=dict(color='royalblue', width=0.6), showlegend=False))
    for x0 in x0_right:
        xs = x0 + c_R * t_frames
        fig.add_trace(go.Scatter(x=xs, y=t_frames, mode='lines', line=dict(color='royalblue', width=0.6), showlegend=False))

    if compressive:
        # Shock: draw shock line x = s * t
        xs_s = s * t_frames
        fig.add_trace(go.Scatter(x=xs_s, y=t_frames, mode='lines', line=dict(color='red', width=3), name=f'Shock x = s t (s={s:.3f})'))
        regime_text = f"Shock (compressive): c_L={c_L:.3f} > c_R={c_R:.3f}, s={s:.3f}"
    else:
        # Rarefaction: draw fan of characteristics from origin with slopes between c_L and c_R
        # a family of characteristic rays x = xi * t with xi in [c_L, c_R]
        n_rays = 41
        slopes = np.linspace(c_L, c_R, n_rays)
        for xi in slopes:
            xs = xi * t_frames
            fig.add_trace(go.Scatter(x=xs, y=t_frames, mode='lines', line=dict(color='green', width=1), showlegend=False, opacity=0.8))
        # also draw bounding characteristic lines
        fig.add_trace(go.Scatter(x=c_L * t_frames, y=t_frames, mode='lines', line=dict(color='green', width=2, dash='dash'), name=f'c_L={c_L:.3f}'))
        fig.add_trace(go.Scatter(x=c_R * t_frames, y=t_frames, mode='lines', line=dict(color='green', width=2, dash='dash'), name=f'c_R={c_R:.3f}'))
        regime_text = f"Rarefaction (expansive): c_L={c_L:.3f} <= c_R={c_R:.3f}"

    # layout: time increases upward
    fig.update_layout(
        title=f"Riemann initial states: ρ_L={rho_L:.3f}, ρ_R={rho_R:.3f} — {regime_text}",
        xaxis_title="x",
        yaxis_title="t (time ↑)",
        yaxis=dict(autorange=False, range=[0, t_max]),
        width=900, height=560
    )

    return fig

# Widgets
rho_L_slider = widgets.FloatSlider(value=0.1, min=0.0, max=1.0, step=0.01, description='ρ_L', continuous_update=False)
rho_R_slider = widgets.FloatSlider(value=0.7, min=0.0, max=1.0, step=0.01, description='ρ_R', continuous_update=False)
tmax_slider  = widgets.FloatSlider(value=3.0, min=0.5, max=6.0, step=0.1, description='t_max', continuous_update=False)

out = widgets.Output()

def update(change=None):
    with out:
        clear_output(wait=True)
        fig = plot_riemann(rho_L_slider.value, rho_R_slider.value, t_max=tmax_slider.value)
        fig.show()

# Attach observers
rho_L_slider.observe(update, names='value')
rho_R_slider.observe(update, names='value')
tmax_slider.observe(update, names='value')

controls = widgets.HBox([rho_L_slider, rho_R_slider, tmax_slider])
display(widgets.VBox([controls, out]))

# initial draw
update()
```