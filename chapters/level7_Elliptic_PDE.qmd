---
title: "Elliptic Partial Differential Equations"
format: html
jupyter: python3
---

**Pavni:** We’ve seen waves (hyperbolic) and diffusion (parabolic). What are elliptic PDEs about?

**Acharya:** Elliptic PDEs describe *steady-state* or equilibrium phenomena where time is no longer present. Typical examples are steady heat conduction, electrostatics (potential problems), and incompressible potential flow.

**Pavni:** So instead of marching forward in time we solve for the entire spatial field at once?

**Acharya:** Exactly. That changes both our modelling viewpoint and the numerical tools: we discretize the spatial domain and solve a (usually large) algebraic system.

##  Prototypical equations

The two classical elliptic equations in two dimensions are

- **Laplace equation** (no sources):
  
  $$
  u_{xx} + u_{yy} = 0,
  $$

- **Poisson equation** (with sources):

  $$
  u_{xx} + u_{yy} = f(x,y).
  $$

Boundary conditions determine a well-posed problem (Dirichlet, Neumann, Robin).


A second-order linear PDE in 2D written as

$$
A u_{xx} + 2B u_{xy} + C u_{yy} + \dots = 0
$$

is **elliptic** at a point if the discriminant satisfies

$$
B^2 - AC < 0.
$$

This local condition corresponds to the absence of real characteristic curves — there is no natural direction for propagation.

##  Boundary conditions

- **Dirichlet:** prescribe $u$ on the boundary (value-driven).  
- **Neumann:** prescribe normal derivative $\partial_n u$ on the boundary (flux-driven).  
- **Robin:** linear combination of Dirichlet and Neumann.

**Pavni:** Which ones are easiest numerically?

**Acharya:** Dirichlet is simplest to impose in most finite-difference or finite-element contexts. Neumann requires consistent discretizations near the boundary (ghost points or one-sided differences).

## Finite difference discretization — Laplace on a square

We illustrate with the unit square $\Omega = (0,1)^2$ and Dirichlet boundary conditions.

Use a uniform grid with spacing $h=1/(N+1)$ and interior nodes $(x_i,y_j)$ where $i,j=1,\dots,N$.

Central differences give the five-point stencil at interior node $(i,j)$:

$$
\frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{h^2} + \frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{h^2} = f_{i,j}.
$$

Rearrange to the canonical form:

$$
- u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} + 4 u_{i,j} = h^2 f_{i,j}.
$$

This couples each grid point to its four neighbours.

## Matrix form and properties

Ordering unknowns lexicographically (e.g. row-wise), the discrete Laplacian leads to a linear system

$$
A \mathbf{u} = \mathbf{b}.
$$

Key properties of the matrix $A$ for the standard five-point Laplacian with Dirichlet BCs:

- symmetric  
- sparse (banded block structure)  
- positive-definite (for Poisson with Dirichlet BCs)

These properties guide solver choices — conjugate gradient (CG) is an excellent option when $A$ is SPD.

##  Simple solvers (algorithmic sketch)

**Pavni:** Which solver should I try first?

**Acharya:** Start with iterative smoothers and then try Krylov methods:

- **Jacobi** (easy, textbook): parallel-friendly but slow.  
- **Gauss–Seidel** (faster; sequential).  
- **Successive Over-Relaxation (SOR)** (tune relaxation parameter $\omega$).  
- **Conjugate Gradient** with an incomplete Cholesky or algebraic multigrid preconditioner for large problems.

## 8. Example: Python — assemble and solve small Poisson

```{python}
#| echo: false
#| code-fold: true
#| code-summary: "Show code"
#| fig-cap: "Poisson solution on unit square (Dirichlet 0, f≡1) and its 3D surface."
#| warning: false
#| message: false
#| fig-width: 6
#| fig-height: 5

import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

# small example N x N interior points
N = 20
h = 1.0/(N+1)

# 1D Laplacian block
T = diags([1,-2,1], [-1,0,1], shape=(N,N)).toarray()
I = np.eye(N)
A = (np.kron(I, T) + np.kron(T, I)) / h**2

# RHS f(x,y) = 1.0
b = np.ones(N*N)

# Solve (for small N we use direct)
u = np.linalg.solve(A, b)

# reshape to 2D for plotting or inspection
U = u.reshape((N,N))

# Build coordinates for plotting
x = np.linspace(h, 1 - h, N)
y = np.linspace(h, 1 - h, N)

# --- 2D heatmap
plt.figure(figsize=(6,5))
plt.imshow(U, origin="lower", extent=[0, 1, 0, 1], aspect="auto")
plt.colorbar(label="u(x,y)")
plt.title("Poisson solution on unit square (Dirichlet 0, f≡1)")
plt.xlabel("x"); plt.ylabel("y"); plt.tight_layout()
plt.show()

# --- 3D surface
from mpl_toolkits.mplot3d import Axes3D  # harmless import; ok if unused
X, Y = np.meshgrid(x, y)
fig = plt.figure(figsize=(6,5))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, U, cmap='viridis')
ax.set_title('3D surface of Poisson solution')
ax.set_xlabel('x'); ax.set_ylabel('y'); ax.set_zlabel('u(x,y)')
plt.tight_layout()
plt.show()
```

